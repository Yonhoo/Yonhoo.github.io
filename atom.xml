<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yonhoo</title>
  <icon>https://yonhoo.github.io/icon.png</icon>
  <subtitle>Tech Blog &amp; Personal Journey</subtitle>
  <link href="https://yonhoo.github.io/atom.xml" rel="self"/>
  
  <link href="https://yonhoo.github.io/"/>
  <updated>2025-08-09T09:10:16.000Z</updated>
  <id>https://yonhoo.github.io/</id>
  
  <author>
    <name>epic</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>领域驱动设计 DDD 实践指南</title>
    <link href="https://yonhoo.github.io/ddd-domain-driven-design-guide/"/>
    <id>https://yonhoo.github.io/ddd-domain-driven-design-guide/</id>
    <published>2025-08-09T09:10:16.000Z</published>
    <updated>2025-08-09T09:10:16.000Z</updated>
    
    
    <summary type="html">深入探讨领域驱动设计(DDD)的核心概念和实践方法，包括贫血模型vs充血模型、战略建模、战术建模、聚合设计等DDD核心思想，以及在微服务架构中的实际应用案例。</summary>
    
    
    
    <category term="软件架构" scheme="https://yonhoo.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
    <category term="设计模式" scheme="https://yonhoo.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="DDD" scheme="https://yonhoo.github.io/tags/DDD/"/>
    
    <category term="领域驱动设计" scheme="https://yonhoo.github.io/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="软件架构" scheme="https://yonhoo.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
    <category term="微服务" scheme="https://yonhoo.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="设计模式" scheme="https://yonhoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="业务建模" scheme="https://yonhoo.github.io/tags/%E4%B8%9A%E5%8A%A1%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>monstache 同步 es 学习</title>
    <link href="https://yonhoo.github.io/monstache-elasticsearch-sync-tutorial/"/>
    <id>https://yonhoo.github.io/monstache-elasticsearch-sync-tutorial/</id>
    <published>2025-06-08T02:00:00.000Z</published>
    <updated>2025-06-08T02:00:00.000Z</updated>
    
    
    <summary type="html">深入学习monstache工具实现MongoDB到Elasticsearch的数据同步，包括全量同步、增量同步、高可用集群、断点续传等核心功能的实现原理和最佳实践。</summary>
    
    
    
    <category term="数据库" scheme="https://yonhoo.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="技术教程" scheme="https://yonhoo.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="MongoDB" scheme="https://yonhoo.github.io/tags/MongoDB/"/>
    
    <category term="Elasticsearch" scheme="https://yonhoo.github.io/tags/Elasticsearch/"/>
    
    <category term="数据同步" scheme="https://yonhoo.github.io/tags/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/"/>
    
    <category term="monstache" scheme="https://yonhoo.github.io/tags/monstache/"/>
    
    <category term="golang" scheme="https://yonhoo.github.io/tags/golang/"/>
    
    <category term="搜索引擎" scheme="https://yonhoo.github.io/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>ClassLoader</title>
    <link href="https://yonhoo.github.io/2024/01/03/classLoader/"/>
    <id>https://yonhoo.github.io/2024/01/03/classLoader/</id>
    <published>2024-01-02T16:00:00.000Z</published>
    <updated>2025-08-09T12:57:20.048Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;类加载机制&quot;&gt;类加载机制&lt;/h3&gt;
&lt;p&gt;  在编译成的Class文件最终都要加载到虚拟机中才能被运行和使用，Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://yonhoo.github.io/categories/Java/"/>
    
    <category term="JVM" scheme="https://yonhoo.github.io/categories/Java/JVM/"/>
    
    
    <category term="ClassLoader" scheme="https://yonhoo.github.io/tags/ClassLoader/"/>
    
    <category term="类加载" scheme="https://yonhoo.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
    <category term="JVM原理" scheme="https://yonhoo.github.io/tags/JVM%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Kafka-Fetch</title>
    <link href="https://yonhoo.github.io/2023/11/27/Kafka-fetch/"/>
    <id>https://yonhoo.github.io/2023/11/27/Kafka-fetch/</id>
    <published>2023-11-26T16:00:00.000Z</published>
    <updated>2025-08-09T12:57:20.048Z</updated>
    
    
    <summary type="html">&lt;p&gt;  每个Broker上都有一个ReplicaManager，它管理每个Partition的数据同步逻辑，因为每个Partition都会存在副本，从而在Broker中的TopicPartition可能是Leader或者Follower。&lt;/p&gt;
&lt;p&gt;  当它是Leader时，就需要处理来自Producer的请求，写入log数据，同时等ISR集合同步完成，如果是Follower，就需要同步来自Leader的log数据，保持数据同步。&lt;/p&gt;
&lt;p&gt;  在ReplicaManager中，就会开启同步Follower线程来FetchMessage。在ReplicaManager中会调用makeFollowers来处理同步Leader数据的逻辑。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式系统" scheme="https://yonhoo.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="消息中间件" scheme="https://yonhoo.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Kafka" scheme="https://yonhoo.github.io/tags/Kafka/"/>
    
    <category term="Consumer" scheme="https://yonhoo.github.io/tags/Consumer/"/>
    
    <category term="消息消费" scheme="https://yonhoo.github.io/tags/%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9/"/>
    
  </entry>
  
  <entry>
    <title>Kafka-replica-server</title>
    <link href="https://yonhoo.github.io/2023/11/26/Kafka-replica-server/"/>
    <id>https://yonhoo.github.io/2023/11/26/Kafka-replica-server/</id>
    <published>2023-11-25T16:00:00.000Z</published>
    <updated>2025-08-09T12:57:20.043Z</updated>
    
    
    <summary type="html">&lt;p&gt;  本文简单介绍当Broker接受到producerRequest的时候，ReplicaManager是如何处理的本地写入和WaitForFollowerFetch&lt;/p&gt;</summary>
    
    
    
    <category term="分布式系统" scheme="https://yonhoo.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="消息中间件" scheme="https://yonhoo.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Kafka" scheme="https://yonhoo.github.io/tags/Kafka/"/>
    
    <category term="副本机制" scheme="https://yonhoo.github.io/tags/%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6/"/>
    
    <category term="高可用" scheme="https://yonhoo.github.io/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Kafka-Concept</title>
    <link href="https://yonhoo.github.io/2023/11/25/Kafka-concept/"/>
    <id>https://yonhoo.github.io/2023/11/25/Kafka-concept/</id>
    <published>2023-11-24T16:00:00.000Z</published>
    <updated>2025-08-09T12:57:22.118Z</updated>
    
    
    <summary type="html">&lt;p&gt;  关于Kafka的文章，主要是为了学习在分布式系统下，非常重要的部分如数据复制，数据分区的真正实践，同时对于消息队列的使用并不是很多，从而通过学习Kafka相关内容来进行深入，当然没有大型项目关于Kafka的深入实践，很难结合业务场景来调优最佳实践和更加深刻的认知，但还是希望通过这种方式来进行入门，了解万变不离其宗的分布式系统下的复杂性。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式系统" scheme="https://yonhoo.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="消息中间件" scheme="https://yonhoo.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Kafka" scheme="https://yonhoo.github.io/tags/Kafka/"/>
    
    <category term="消息队列" scheme="https://yonhoo.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    <category term="分布式" scheme="https://yonhoo.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Kafka-Producer</title>
    <link href="https://yonhoo.github.io/2023/11/25/Kafka-replica-producer/"/>
    <id>https://yonhoo.github.io/2023/11/25/Kafka-replica-producer/</id>
    <published>2023-11-24T16:00:00.000Z</published>
    <updated>2025-08-09T12:57:20.037Z</updated>
    
    
    <summary type="html">&lt;p&gt;  如今在维护各个微服务下，考虑到最多的就是分布式系统的可用性--CAP，那么就像数据密集型服务描述的那样，需要考虑分布式系统下数据复制、数据分区、分布式事务，本节通过看kafka的多分区复制方式，来学习数据复制中需要考虑到的通用处理。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式系统" scheme="https://yonhoo.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="消息中间件" scheme="https://yonhoo.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Kafka" scheme="https://yonhoo.github.io/tags/Kafka/"/>
    
    <category term="Producer" scheme="https://yonhoo.github.io/tags/Producer/"/>
    
    <category term="消息发送" scheme="https://yonhoo.github.io/tags/%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/"/>
    
  </entry>
  
  <entry>
    <title>Netty write 流程</title>
    <link href="https://yonhoo.github.io/2023/10/15/netty_write/"/>
    <id>https://yonhoo.github.io/2023/10/15/netty_write/</id>
    <published>2023-10-14T16:00:00.000Z</published>
    <updated>2025-08-09T12:57:22.118Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;1-channelpipline 传播事件&quot;&gt;1. ChannelPipline 传播事件&lt;/h2&gt;
&lt;p&gt;  每一个Channel都会分配一个新的ChannelPipline，所有的出入站事件都会流经ChannelPipline来进行处理。&lt;/p&gt;
&lt;p&gt;  其中处理每一个事件的主要是ChannelHandler，例如ChannelOutboundHandler、ChannelInboundHandler分别用来处理出入站事件。通过调用ChannelHandlerContext实现，它将被转发给同一超类型的下一个ChannelHandler进行处理。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://yonhoo.github.io/categories/Java/"/>
    
    <category term="网络编程" scheme="https://yonhoo.github.io/categories/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Netty" scheme="https://yonhoo.github.io/tags/Netty/"/>
    
    <category term="NIO" scheme="https://yonhoo.github.io/tags/NIO/"/>
    
    <category term="异步编程" scheme="https://yonhoo.github.io/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="https://yonhoo.github.io/2023/10/14/distribute_transaction/"/>
    <id>https://yonhoo.github.io/2023/10/14/distribute_transaction/</id>
    <published>2023-10-13T16:00:00.000Z</published>
    <updated>2025-08-09T12:52:54.354Z</updated>
    
    
    <summary type="html">&lt;p&gt;  在如今的项目实践中，存在多个微服务之间互相通信，对于一个外卖服务，涉及到订单支付，优惠券扣减，餐厅下单，外卖配送等，在微服务设计下，就需要保证多个系统之间的数据一致性，这个时候就需要考虑到分布式事务来处理一致性问题。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式系统" scheme="https://yonhoo.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="事务" scheme="https://yonhoo.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E4%BA%8B%E5%8A%A1/"/>
    
    
    <category term="微服务" scheme="https://yonhoo.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="分布式事务" scheme="https://yonhoo.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="数据一致性" scheme="https://yonhoo.github.io/tags/%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper 简介与使用场景</title>
    <link href="https://yonhoo.github.io/2023/05/20/zookeeper_utilize/"/>
    <id>https://yonhoo.github.io/2023/05/20/zookeeper_utilize/</id>
    <published>2023-05-19T16:00:00.000Z</published>
    <updated>2025-08-09T12:55:29.231Z</updated>
    
    
    <summary type="html">&lt;img src=&quot;/2023/05/20/zookeeper_utilize/zookeeper.png&quot; class=&quot;&quot; width=&quot;300&quot;&gt;  
&lt;p&gt;  Zookeeper的视图结构和标准的Unix文件系统非常类似，但没有引入传统文件系统中目录和文件等相关概念，而是使用了其特有的“数据节点”概念，我们称之为ZNode。ZNode是Zookeeper中数据的最小单元，每个ZNode上都可以保存数据，同时还可以挂载子节点，因此构成了一个层次化的命名空间，我们称之为树。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式系统" scheme="https://yonhoo.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="中间件" scheme="https://yonhoo.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Zookeeper" scheme="https://yonhoo.github.io/tags/Zookeeper/"/>
    
    <category term="分布式协调" scheme="https://yonhoo.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83/"/>
    
    <category term="配置管理" scheme="https://yonhoo.github.io/tags/%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>任务调度</title>
    <link href="https://yonhoo.github.io/2023/04/22/task_scheduler/"/>
    <id>https://yonhoo.github.io/2023/04/22/task_scheduler/</id>
    <published>2023-04-21T16:00:00.000Z</published>
    <updated>2025-08-09T12:55:22.596Z</updated>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;任务场景&lt;br&gt;
  在支付宝中，如果你在蚂蚁森林里面种植了一颗树苗，它会根据用户每天使用支付宝的各种场景：地铁出行，线下支付等来生成相应的能量，每天早上，支付宝会通知每个用户收取能量，以便他们能够种植更多的树苗。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="分布式系统" scheme="https://yonhoo.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="任务调度" scheme="https://yonhoo.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"/>
    
    
    <category term="Quartz" scheme="https://yonhoo.github.io/tags/Quartz/"/>
    
    <category term="分布式任务" scheme="https://yonhoo.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1/"/>
    
    <category term="定时任务" scheme="https://yonhoo.github.io/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收与检查工具</title>
    <link href="https://yonhoo.github.io/2023/04/09/GCWithTroubleShoot/"/>
    <id>https://yonhoo.github.io/2023/04/09/GCWithTroubleShoot/</id>
    <published>2023-04-08T16:00:00.000Z</published>
    <updated>2025-08-09T12:55:15.073Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;java内存区域&quot;&gt;java内存区域&lt;/h2&gt;
&lt;p&gt;  运行时数据区域&lt;/p&gt;
&lt;img src=&quot;/2023/04/09/GCWithTroubleShoot/runtime_region.png&quot; class=&quot;&quot;&gt;  
&lt;ol&gt;
&lt;li&gt;程序计数器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;  当前线程私有，是当前线程所执行的字节码的行号指示器&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;java虚拟机栈&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;  当前线程私有，每个方法被执行时的栈帧，用于储存局部变量表、操作数栈，动态连接，方法出口等信息动态连接作用就是为了将这些方法符号引用转换为调用方法的直接引用，因为有的对象调用方法时动态生成的，所以在编译器不能确定要执行的符号，从而需要在运行时，去方法区动态的找。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://yonhoo.github.io/categories/Java/"/>
    
    <category term="性能优化" scheme="https://yonhoo.github.io/categories/Java/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="JVM" scheme="https://yonhoo.github.io/tags/JVM/"/>
    
    <category term="GC" scheme="https://yonhoo.github.io/tags/GC/"/>
    
    <category term="性能调优" scheme="https://yonhoo.github.io/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
</feed>
